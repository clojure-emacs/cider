\input texinfo   @c -*-texinfo-*-
@tex
\global\urefurlonlylinktrue
\global\def\linkcolor{0.4 0 0}
\global\def\urlcolor{0.4 0 0}
@end tex

@alias pkg = file
@alias branch = t
@alias pkgrepo = t
@alias buffer = t
@alias prog = t
@alias clojar = file
@alias clojf = t

@setfilename cider.info
@settitle CIDER

@copying
CIDER, the Clojure Interactive Development Environment that Rocks.

Copyright @copyright{} 2012--2015
Tim King,
Phil Hagelberg,
Bozhidar Batsov,
Hugo Duncan,
Steve Purcell and
@uref{http://github.com/clojure-emacs/cider/contributors, contributors}.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
A copy of the license is included in the section entitled ``GNU
Free Documentation License''.

A copy of the license is also available from the Free Software
Foundation Web site at @url{http://www.gnu.org/licenses/fdl.html}.
@end quotation

The document was typeset with
@uref{http://www.texinfo.org, GNU Texinfo}.
@end copying

@titlepage
@title CIDER
@subtitle The @b{C}lojure @b{I}nteractive @b{D}evelopment @b{E}nvironment that @b{R}ocks.
@vskip 0pt plus 1 filll
@center @image{logo,4in}
@author @url{http://www.github.com/clojure-emacs/cider}
@page
@vskip 0pt plus 1 filll
CIDER (formerly @pkg{nrepl.el}) is an @emph{awesome} Clojure IDE for
Emacs built on top of @uref{http://github.com/clojure/tools.nrepl,
nREPL}, the Clojure networked REPL server.  It's a great alternative to
the now-deprecated combination of SLIME and
@uref{http://github.com/technomancy/swank-clojure, swank-clojure}.

If you're interested in details about CIDER's history and architecture you can
check out the Clojure/conj presentation
@uref{http://www.youtube.com/watch?v=4X-1fJm25Ww&list=PLZdCLR02grLoc322bYirANEso3mmzvCiI&index=6,
      The Evolution of the Emacs tooling for Clojure}.

@vskip 0pt plus 2filll
@insertcopying
@end titlepage

@contents

@dircategory Emacs
@direntry
* Cider: (cider). The Clojure Interactive Development Environment that Rocks
@end direntry

@ifnottex
@node Top
@top CIDER

@insertcopying
@end ifnottex

@c Generate the nodes for this menu with `C-c C-u C-m'.
@menu
* Summary of Features::
* Installation::
* CIDER nREPL Middleware::
* Configuration::
* Basic Usage::
* Keyboard Shortcuts::
* Requirements::
* Caveats::
* Troubleshooting::
* Documentation::
* Changelog::
* Team::
* Release Policy::
* Logo::
* Contributing::
* License::
* Copying This Manual::
@end menu

@node Summary of Features
@chapter Summary of Features
CIDER packs plenty of features.  Here are some of them (in no particular order):

@itemize
@item Powerful REPL
@item Interactive code evaluation
@item Compilation notes (error and warning highlighting)
@item Human-friendly stacktraces
@item Smart code completion
@item Definition lookup
@item Documentation lookup
@item Resource lookup
@item Apropos
@item Debugger
@item Value inspector
@item Function tracing
@item Interactive macroexpansion
@item @uref{http://conj.io, Grimoire} integration
@item @pkg{clojure.test} integration
@item Classpath browser
@item Namespace browser
@item nREPL session management
@item Scratchpad
@item Minibuffer code evaluation
@item Integration with @uref{http://company-mode.github.io, company-mode}
      and @uref{http://github.com/clojure-emacs/ac-cider,
      auto-complete-mode}
@end itemize


@node Installation
@chapter Installation
The canonical way to install CIDER is via @pkg{package.el}, but you can
choose other possibilities available for your Emacs or operating system.

@section Prerequisites
You'll need to have Emacs installed (preferably the latest stable release).  If
you're new to Emacs you might want to read
@uref{http://clojure-doc.org/articles/tutorials/emacs.html, this tutorial},
dedicated to setting up Emacs for Clojure development, first.

@subsection Upgrading from @pkg{nrepl.el}

Before installing CIDER make sure you've removed the old @pkg{nrepl.el}
package and all packages that depend on it.  Use only packages updated to work
with CIDER!

You'll also need to adjust your config accordingly, as most settings were
@c TODO: update configuration link
renamed in CIDER.  Consult the @uref{#configuration, Configuration} section of the
@file{README} for more details.

@subsection Upgrading from @pkg{clojure-test-mode}

CIDER 0.7 ships a replacement for the deprecated @command{clojure-test-mode}
called @command{cider-test}.  Please, make sure you've uninstalled
@command{clojure-test-mode} if you're using CIDER 0.7 as
@command{clojure-test-mode} sometimes interferes with CIDER's REPL
initialization.

@section Via @pkg{package.el}

@pkg{package.el} is the built-in package manager in Emacs.

CIDER is available on all major, community-maintained @pkg{package.el}
repositories: @uref{http://melpa.milkbox.net, MELPA},
@uref{http://melpa-stable.milkbox.net, MELPA-stable}, and
@uref{http://marmalade-repo.org, Marmalade}.

@c TODO: *sea 2015-08-02 Is this still accurate?
Be aware that at the time of this writing none of these repositories have TLS
enabled and installing packages from them @emph{cannot} be done securely.

You can install CIDER with @kbd{M-x package-install @kbd{RET} cider RET} or by
adding this bit of code to your initialization file:
@lisp
(unless (package-installed-p 'cider)
  (package-install 'cider))
@end lisp
If the installation doesn't work, try refreshing the package list with @kbd{M-x
package-refresh-contents RET}.

Keep in mind that MELPA packages are built automatically from the @branch{master}
branch, meaning bugs might creep in there from time to time.  Nevertheless,
installing from MELPA is the recommended way of obtaining CIDER, as the
@branch{master} branch is normally quite stable and ``stable'' (tagged) builds are
released somewhat infrequently.

With the most recent builds of Emacs, you can pin CIDER to always use
MELPA-stable by adding this to your Emacs initialization:

@lisp
(add-to-list 'package-pinned-packages '(cider . "melpa-stable") t)
@end lisp

@strong{CIDER has dependencies (e.g. @pkg{queue}) that are only available in
the @uref{http://elpa.gnu.org, GNU ELPA repository}.  It's the only repository
enabled by default and you should not disable it!}

@section Via @pkg{el-get}

@uref{http://github.com/dimitri/el-get, @pkg{el-get}} is another popular package
manager for Emacs.  If you're an @pkg{el-get} user, just use @kbd{M-x
el-get-install}.

@section Gentoo Distribution

On Gentoo, CIDER can be installed using
@uref{http://github.com/jauhien/gs-elpa, gs-elpa tool}.  Just add the
@pkgrepo{gnu-elpa} and @pkgrepo{melpa-stable} repositories (if they are still not added) and
emerge CIDER as normal package:
@verbatim
layman -a gnu-elpa
layman -a melpa-stable
emerge -va app-emacs/cider
@end verbatim

If you need the latest @command{git} version, install CIDER from the MELPA
overlay instead of MELPA-stable.  Consult the
@uref{http://wiki.gentoo.org/wiki/GNU_Emacs#Additional_elisp_packages,
documentation} in case of any questions.

@section Manual

You can install CIDER manually by placing CIDER on your @var{load-path}
and @command{require}ing it.  Many people favor the folder
@file{~/.emacs.d/vendor}:
@lisp
(add-to-list 'load-path "~/emacs.d/vendor")
(require 'cider)
@end lisp
Keep in mind that CIDER depends on @pkg{clojure-mode}, @pkg{dash.el} and
@pkg{pkg-info} so you'll have to install them as well.

@section Emacs Prelude

CIDER comes bundled in @uref{http://github.com/bbatsov/prelude, Emacs
Prelude}.  If you're a Prelude user, you can start using it right away.

@section Emacs Live

CIDER comes bundled in @uref{http://github.com/overtone/emacs-live, Emacs Live}.
If you're using Emacs Live, you're already good to go.


@node CIDER nREPL Middleware
@chapter CIDER nREPL Middleware
@section Using Leiningen

Much of CIDER's functionality depends on the presence of CIDER's own
@uref{http://github.com/clojure-emacs/cider-nrepl, nREPL middleware}.  Use the
plugin for convenient defaults -- either in your project's @file{project.clj}
file or in the @var{:user} profile in @file{~/.lein/profiles.clj}.
@lisp
:plugins [[cider/cider-nrepl "x.y.z"]]
@end lisp

A minimal @file{profiles.clj} for CIDER would be:
@lisp
@{:user @{:plugins [[cider/cider-nrepl "0.9.1"]]@}@}
@end lisp

@section Using Boot

Boot users can configure the tool to include the middleware automatically in
all of their projects using a @file{~/.boot/profile.boot} file like so:

@lisp
(require 'boot.repl)

(swap! boot.repl/*default-dependencies*
       concat '[[cider/cider-nrepl "0.9.1"]])

(swap! boot.repl/*default-middleware*
       conj 'cider.nrepl/cider-middleware)
@end lisp

For more information, visit
@uref{http://github.com/boot-clj/boot/wiki/Cider-REPL, @pkg{boot-clj}
wiki}.

@section Using embedded nREPL server

If you're embedding nREPL in your application you'll have to start the
server with CIDER's own nREPL handler.

@lisp
(ns my-app
  (:require [clojure.tools.nrepl.server :as nrepl-server]
            [cider.nrepl :refer (cider-nrepl-handler)]))

(defn -main
  []
  (nrepl-server/start-server :port 7888 :handler cider-nrepl-handler))
@end lisp

It goes without saying that your project should depend on @pkg{cider-nrepl}.

@samp{x.y.z} should match the version of CIDER you're currently using
(say @samp{0.7.1}).  For snapshot releases of CIDER you should use the
snapshot of the plugin as well (say @samp{0.7.1-SNAPSHOT}).

Note that you need to use at least CIDER 0.7 for the nREPL middleware to work
properly.  Don't use @pkg{cider-nrepl} with CIDER 0.6.

@node Configuration
@chapter Configuration

You can certainly use CIDER without configuring it any further, but here
are some ways other folks are adjusting their CIDER experience.

@section Basic configuration

@enumerate
@item
Enable @command{eldoc-mode} in Clojure buffers:
@lisp
(add-hook 'cider-mode-hook #'eldoc-mode)
@end lisp

@item
Suppress auto-enabling of @command{cider-mode} in @command{clojure-mode}
buffers, when starting CIDER:
@lisp
(setq cider-auto-mode nil)
@end lisp

By default CIDER will enable @command{cider-mode} in all
@command{clojure-mode} buffers when the first CIDER connection is
established.  It will also add a @command{clojure-mode} hook to enable it
on newly created @command{clojure-mode} buffers.  The configuration
snippet above allows you to override this (somewhat non-standard)
behavior.

@item
Don't log communication with the nREPL server:
@lisp
(setq nrepl-log-messages nil)
@end lisp

Basically, this will dispose of the buffer @buffer{*nrepl-messages*}.  The
@c alias buffers
communication log is invaluable for debugging CIDER issues, so you're
generally advised to keep it around.

@item
You can hide the @buffer{*nrepl-connection*} and @buffer{*nrepl-server*} buffers
@c alias buffers
from appearing in some buffer switching commands like
@command{switch-to-buffer} (@kbd{C-x b}) like this:
@lisp
(setq nrepl-hide-special-buffers t)
@end lisp

When using @command{switch-to-buffer}, pressing @key{SPC} after the
command will make the hidden buffers visible.  They'll always be visible
in @command{list-buffers} (@kbd{C-x C-b}).

@item
By default, interactive commands that require a symbol will prompt for
the symbol, with the prompt defaulting to the symbol at point.  You can
set @var{cider-prompt-for-symbol} to @samp{nil} to instead try the
command with the symbol at point first, and only prompt if that fails.

@item
You can control the @kbd{TAB} key behavior in the REPL via the
@var{cider-repl-tab-command} variable.  While the default command
@var{cider-repl-indent-and-complete-symbol} should be an adequate choice
for most users, it's very easy to switch to another command if you wish
to.  For instance if you'd like @kbd{TAB} to only indent (maybe
because you're used to completing with @kbd{M-TAB}) use the
following snippet:
@lisp
(setq cider-repl-tab-command #'indent-for-tab-command)
@end lisp

@item
To prefer local resources to remote (TRAMP) ones when both are
available:
@lisp
(setq cider-prefer-local-resources t)
@end lisp

@item
Prevent the auto-display of the REPL buffer in a separate window after
connection is established:
@lisp
(setq cider-repl-pop-to-buffer-on-connect nil)
@end lisp

@item
Configure whether the error buffer with stacktraces should be
automatically shown on error:
@itemize
@item
Don't show on error:
@lisp
(setq cider-show-error-buffer nil)
@end lisp
Independently of the value of @var{cider-show-error-buffer}, the error
buffer is always generated in the background.  Use
@command{cider-visit-error-buffer} to visit this buffer.

@item
Selective strategies:
@lisp
(setq cider-show-error-buffer 'except-in-repl)
@end lisp
or
@lisp
(setq cider-show-error-buffer 'only-in-repl)
@end lisp
@end itemize

@item
To disable auto-selection of the error buffer when it's displayed:
@lisp
(setq cider-auto-select-error-buffer nil)
@end lisp

@item
If using the @pkg{wrap-stacktrace} middleware from @pkg{cider-nrepl},
error buffer stacktraces may be filtered by default.  Valid filter types
include @samp{java}, @samp{clj}, @samp{repl}, @samp{tooling}, and
@samp{dup}.  Setting this to @samp{nil} will show all stacktrace frames.
@lisp
(setq cider-stacktrace-default-filters '(tooling dup))
@end lisp

@item
Error messages may be wrapped for readability.  If this value is nil, messages
will not be wrapped; if it is truthy but non-numeric, the default
@var{fill-column} will be used.
@lisp
(setq cider-stacktrace-fill-column 80)
@end lisp

@item
The REPL buffer name has the format @buffer{*cider-repl
@samp{project-name}*}.  Change the separator from space to something
else by overriding @var{nrepl-buffer-name-separator}:
@lisp
(setq nrepl-buffer-name-separator "-")
@end lisp

@item
The REPL buffer name can also display the port on which the nREPL server
is running.  Buffer name will look like @buffer{*cider-repl
@samp{project-name}:@samp{port}*}.
@lisp
(setq nrepl-buffer-name-show-port t)
@end lisp

@item
Make @kbd{C-c C-z} switch to the CIDER REPL buffer in the current
window:
@lisp
(setq cider-repl-display-in-current-window t)
@end lisp

@item
Prevent @kbd{C-c C-k} from prompting to save the file corresponding
to the buffer being loaded, if it's modified:
@lisp
(setq cider-prompt-save-file-on-load nil)
@end lisp

@item
Change the result prefix for REPL evaluation (by default there's no
prefix):
@lisp
(setq cider-repl-result-prefix ";; => ")
@end lisp

And here's the result of that change:

@verbatim
user> (+ 1 2)
;; => 3
@end verbatim

@item
Change the result prefix for interactive evaluation (default is
@code{"=> "}):
@lisp
(setq cider-interactive-eval-result-prefix ";; => ")
@end lisp

To remove the prefix altogether, just set it to an empty string
(@code{""}).

@item
Normally code you input in the REPL is font-locked with
@var{cider-repl-input-face} (after you press @key{RET}) and results are
font-locked with @var{cider-repl-result-face}.  If you want them to be
font-locked as in @command{clojure-mode}, use the following:
@lisp
(setq cider-repl-use-clojure-font-lock t)
@end lisp

@item
You can control the @kbd{C-c C-z} key behavior of switching to the REPL buffer
with the @var{cider-switch-to-repl-command} variable.  While the default command
@command{cider-switch-to-relevant-repl-buffer} should be an adequate choice for
most users, @command{cider-switch-to-current-repl-buffer} offers a simpler
alternative where CIDER will not attempt to match the correct REPL buffer based
on underlying project directories:
@lisp
(setq cider-switch-to-repl-command
      #'cider-switch-to-current-repl-buffer)
@end lisp

@item
You can configure known endpoints used by the CIDER command offered via
a completing read.  This is useful if you have a list of common
host/ports you want to establish remote nREPL connections to.  Using an
optional label is helpful for identifying each host.
@lisp
(setq cider-known-endpoints
      '(("host-a" "10.10.10.1" "7888")
        ("host-b" "7888")))
@end lisp

@item
If you are targeting the JVM and prefer a local copy of the JDK API
documentation over Oracle's official copy (e.g., for
@uref{http://docs.oracle.com/javase/8/docs/api, JavaSE 8}), per nREPL's
@pkg{javadoc-info} logic (accurate as of 29 Dec 2014), you can arrange your
project to include the root path of the local API doc (i.e., where the
@file{index.html} is located) to be included on your classpath (i.e., where the
doc HTML files can be located by @clojar{clojure.java.io/resource}).  For example,
for Leiningen, with the local API path being @file{/usr/share/doc/java/api/},
put the following line in @file{project.clj}:
@lisp
:dev @{:resource-paths ["/usr/share/doc/java/api/"]@}
@end lisp
@emph{or} the following line in @file{@env{$HOME}/.lein/profiles.clj}:
@lisp
:user @{:resource-paths ["/usr/share/doc/java/api/"]@}
@end lisp
More detail can be found
@uref{http://github.com/clojure-emacs/cider/issues/930, on issue #930}.
@end enumerate

@section Running tests

If your tests are not following the @file{some.ns-test} naming
convention you can customize the variable
@var{cider-test-infer-test-ns}.  It should be bound to a function that
takes the current namespace and returns the matching test namespace
(which may be the same as the current namespace).

If you want to view the test report regardless of whether the tests have
passed or failed:
@lisp
(setq cider-test-show-report-on-success t)
@end lisp

@section Code reloading

@command{cider-refresh} wraps @uref{http://github.com/clojure/tools.namespace,
@clojar{clojure.tools.namespace}}, and as such the same
@uref{http://github.com/clojure/tools.namespace#reloading-code-motivation,
benefits} and
@uref{http://github.com/clojure/tools.namespace#reloading-code-preparing-your-application,
caveats} regarding writing reloadable code also apply.

Calling @command{cider-refresh} will cause all modified Clojure files on the
classpath to be reloaded.  You can also provide a single prefix argument to
reload all Clojure files on the classpath unconditionally, or a double prefix
argument to first clear the state of the namespace tracker before reloading.

The above three operations are analogous to
@uref{http://clojure.github.io/tools.namespace/#clojure.tools.namespace.repl/refresh,
@clojf{clojure.tools.namespace.repl/refresh}},
@uref{http://clojure.github.io/tools.namespace/#clojure.tools.namespace.repl/refresh-all,
@clojf{clojure.tools.namespace.repl/refresh-all}} and
@uref{http://clojure.github.io/tools.namespace/#clojure.tools.namespace.repl/clear,
@clojf{clojure.tools.namespace.repl/clear}} (followed by a normal refresh),
respectively.

You can define Clojure functions to be called before reloading, and
after a successful reload, when using @command{cider-refresh}:
@lisp
(setq cider-refresh-before-fn "user/stop-system!"
      cider-refresh-after-fn "user/start-system!")
@end lisp

These must be set to the namespace-qualified names of variables bound to
functions of no arguments.  The functions must be synchronous (blocking)
and are expected to be side-effecting -- they will always be executed
serially, without retries.

@section REPL history

@itemize
@item
To make the REPL history wrap around when its end is reached:
@lisp
(setq cider-repl-wrap-history t)
@end lisp

@item
To adjust the maximum number of items kept in the REPL history:
@lisp
(setq cider-repl-history-size 1000) ; the default is 500
@end lisp

@item
To store the REPL history in a file:
@lisp
(setq cider-repl-history-file "path/to/file")
@end lisp
@end itemize

Note that the history is written to the file when you kill the REPL
buffer (which includes invoking @command{cider-quit}) or you quitting Emacs.

@section Minibuffer completion

Out-of-the box CIDER uses the standard @command{completing-read} Emacs
mechanism.  While it's not fancy, it certainly gets the job done (just
press @key{TAB}).  There are, however, ways to improve upon the standard
completion if you wish to.

@subsection @pkg{icomplete}
@pkg{icomplete} is bundled with Emacs and enhances the default
minibuffer completion:
@lisp
(require 'icomplete)
@end lisp

@subsection @pkg{ido}
@pkg{ido} is also bundled with Emacs and offers more features than
@pkg{icomplete}.  If you are using @pkg{ido}, be sure to use both
@pkg{ido-everywhere} and
@uref{http://github.com/DarwinAwardWinner/ido-ubiquitous,
@pkg{ido-ubiquitous}}.  You might also want to install
@uref{http://github.com/lewang/flx, @pkg{flx-ido}}.

@section Auto-completion
CIDER users are advised to use @uref{http://company-mode.github.io, Company} to
enable auto-completion inside of source code and REPL buffers.  To install
Company, use: @kbd{M-x package-install @key{RET} company @key{RET}}

After installation, Company can be turned on globally:
@lisp
(global-company-mode)
@end lisp
or through mode-specific hooks:
@lisp
(add-hook 'cider-repl-mode-hook #'company-mode)
(add-hook 'cider-mode-hook #'company-mode)
@end lisp

When Company is enabled, it will receive completion information from
@command{cider-complete-at-point} and requires no additional setup or
plugins.

If you'd prefer to trigger completions manually, you can add this to you
configuration:
@lisp
; never start completions automatically
(setq company-idle-delay nil)
; use meta+tab, i.e. C-M-i or M-TAB, as manual trigger
(global-set-key (kbd "M-TAB") #'company-complete)
@end lisp

To make @key{TAB} complete without losing the ability to manually
indent, you can add this to your configuration:
@lisp
(global-set-key (kbd "TAB") #'company-indent-or-complete-common)
@end lisp

@command{company-indent-or-complete-common} is available only in
@command{company-mode} v0.9+ (at the time of writing, it's still in
development).

@subsection Migrating from @pkg{auto-complete-mode}
@enumerate
@item
Disable @command{ac-cider-setup} or @command{ac-nrepl-setup} from
running on CIDER hooks.
@item
Remove @command{cider-mode} and @command{cider-repl-mode} from the
@var{ac-modes} list.
@end enumerate

@subsection Completion annotations

Completion candidates will be annotated by default with an abbreviation
corresponding to their type, and (contextually) their namespace.  The
function used to format the annotation can be configured by
@var{cider-annotate-completion-function}.  The abbreviations used are
configured by @var{cider-completion-annotations-alist} and the context
in which their namespace is included is configured by
@var{cider-completion-annotations-include-ns}.

Completion annotations can be disabled by setting
@var{cider-annotate-completion-candidates} to @samp{nil}.

@iftex
@center @image{../screenshots/completion-annotations, 4in}
@end iftex

@section Integration with other modes

@itemize
@item
Enabling `CamelCase' support for editing commands (like
@command{forward-word}, @command{backward-word}, etc.) in the REPL is
quite useful since we often have to deal with Java class and method
names.  The built-in Emacs minor mode @command{subword-mode} provides
such functionality:
@lisp
(add-hook 'cider-repl-mode-hook #'subword-mode)
@end lisp

@item
The use of @uref{http://mumble.net/~campbell/emacs/paredit.html,
paredit} when editing Clojure (or any other Lisp) code is @emph{highly}
recommended.  You're probably using it already in your
@command{clojure-mode} buffers (if you're not, you probably should).
You might also want to enable Paredit in the REPL buffer as well:
@lisp
(add-hook 'cider-repl-mode-hook #'paredit-mode)
@end lisp

@item
@uref{http://github.com/Fuco1/smartparens, SmartParens} is an excellent
alternative to Paredit.  Many Clojure hackers have adopted it recently
and you might want to give it a try as well.  To enable SmartParens in
the REPL buffer, use the following configuration:
@lisp
(add-hook 'cider-repl-mode-hook #'smartparens-strict-mode)
@end lisp

@item
@uref{http://github.com/Fanael/rainbow-delimiters, RainbowDelimiters} is
a minor mode which highlights parentheses, brackets, and braces
according to their depth.  Each successive level is highlighted in a
different color.  This makes it easy to spot matching delimiters, orient
yourself in the code, and tell which statements are at a given depth.
Assuming you've already installed RainbowDelimiters you can enable it in
the REPL like this:
@lisp
(add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode)
@end lisp

@item
@uref{http://cx4a.org/software/auto-complete, @pkg{auto-complete}} is a popular
Emacs interactive auto-completion framework.
@uref{http://github.com/clojure-emacs/ac-cider, ac-cider} provides a completion
source for @command{auto-complete-mode}, including, where CIDER provides it,
pop-up documentation for completed symbols.

@item
@uref{http://github.com/hchbaw/eval-sexp-fu.el, @pkg{eval-sexp-fu}}
provides some visual feedback when evaluating expressions.
@uref{http://github.com/clojure-emacs/cider-eval-sexp-fu,
@pkg{cider-eval-sexp-fu}} provides CIDER integration for
@pkg{eval-sexp-fu}.
@lisp
(require 'cider-eval-sexp-fu)
@end lisp
@end itemize

@section Overlays

When you evaluate code in Clojure files, the result is displayed in the buffer
itself, in an overlay right after the evaluated code.  If you want this overlay
to be font-locked (syntax-highlighted) like Clojure code, customize
@var{cider-overlays-use-font-lock}:
@lisp
(setq cider-overlays-use-font-lock t)
@end lisp

You can disable overlays entirely (and display results in the echo-area at the
bottom) with @var{cider-use-overlays}:
@lisp
(setq cider-use-overlays nil)
@end lisp

@node Basic Usage
@chapter Basic Usage
The only requirement to use CIDER is to have a nREPL server to which it may
connect.  Many Clojurians favour the use of the Leiningen or Boot tools to start
an nREPL server, but the use of Leiningen or Boot is not a prerequisite to use
CIDER (but it *is* required if you want to use the @command{cider-jack-in}
command.

@section Setting up a Leiningen or Boot project (optional)
@uref{http://leiningen.org, Leiningen} is the de facto standard build/project
management tool for Clojure.  @uref{http://boot-clj.com, Boot} is a newer build
tool offering abstractions and libraries to construct more complex build
scenarios.  Both have a similar scope to the Maven build tool favoured by Java
developers (and they actually reuse many things from the Maven ecosystem).

CIDER features a command called @command{cider-jack-in} that will start an nREPL
server for a particular Leiningen or Boot project and connect to it
automatically.  This functionality depends on Leiningen 2.x (preferably 2.5+) or
Boot 2.0.0+.  Older versions are not supported.  For Leiningen, follow the
installation instructions on its web site to get it up and running and
afterwards create a project like this:

@verbatim
$ lein new demo
@end verbatim

The two main ways to obtain an nREPL connection are discussed in the following
sections of the manual.

@section Launch an nREPL server and client from Emacs
Simply open in Emacs a file belonging to your @t{lein} or @t{boot} project (like
@file{foo.clj}) and type @kbd{M-x cider-jack-in}.  This will start a nREPL with
all the dependencies loaded in, plus a CIDER client connected to it.

Alternative you can use @kbd{C-u M-x cider-jack-in} to specify the name of
a @prog{lein} or @prog{boot} project, without having to visit any file in it.

@section Connect to a running nREPL server
You can go to your project's directory in a terminal and use:
@verbatim
$ lein repl
@end verbatim
or with Boot:
@verbatim
$ boot repl wait
@end verbatim
Alternatively you can start nREPL either manually or by the facilities provided
by your project build tool (Maven, etc.).

After you get your nREPL server, running go back to Emacs.  Typing there
@kbd{M-x cider-connect} will allow you to connect to the running nREPL server.

@section Using the CIDER minor mode
CIDER comes with a handy minor mode called @command{cider-mode} (complementing
@command{clojure-mode}) that allows you to evaluate code in your Clojure source
files and load it directly in the REPL.  A list of all available commands is
available in the CIDER menu and in the following section of this manual.

@section Pretty printing in the REPL
Make the REPL always pretty-print the results of your commands.  Note that this
will not work correctly with forms such as @code{(def a 1) (def b2)} and it
expects @clojar{clojure.pprint} to have been required already (the default in more
recent versions of Clojure):
@kbd{M-x cider-repl-toggle-pretty-printing}

@section Limiting printed output in the REPL
Accidentally printing large objects can be detrimental to your productivity.
Clojure provides the @var{*print-length*} variable which, if set, controls how
many items of each collection the printer will print.  You can supply a default
value for REPL sessions via the @t{global-vars} section of your Leiningen
project's configuration.
@lisp
:global-vars @{*print-length* 100@}
@end lisp

@section ClojureScript usage
ClojureScript support relies on the
[piggieback](http://github.com/cemerick/piggieback) nREPL middleware being
present in your REPL session.

@enumerate
@item
Add the following dependencies to your @file{project.clj}:
@lisp
[com.cemerick/piggieback "0.2.1"]
[org.clojure/clojure "1.7.0"]
@end lisp
as well as the following option:
@lisp
:repl-options @{:nrepl-middleware [cemerick.piggieback/wrap-cljs-repl]@}
@end lisp

@item
Issue @kbd{M-x customize-variable @kbd{RET} cider-cljs-repl} if you'd like to
change the REPL used (the default is @samp{rhino}).

@item
Open a file in your project and issue @kbd{M-x cider-jack-in-clojurescript}.
This will start up the nREPL server, and then create two REPL buffers for you,
one in Clojure and one in ClojureScript.  All usual CIDER commands will be
automatically directed to the appropriate REPL, depending on whether you're
visiting a @file{.clj} or a @file{.cljs} file.
@end enumerate

@heading Browser-connected ClojureScript REPL

Using Weasel, you can also have a browser-connected REPL.

@enumerate
@item
Add @code{[weasel "0.7.0"]} to your project's @code{:dependencies}.

@item
Issue @kbd{M-x customize-variable @kbd{RET} cider-cljs-repl} and choose the
@samp{Weasel} option.

@item
Add this to your ClojureScript code:
@lisp
(ns my.cljs.core
(:require [weasel.repl :as repl]))
(repl/connect "ws://localhost:9001")
@end lisp

@item
Open a file in your project and issue @kbd{M-x cider-jack-in-clojurescript}.
@end enumerate

Provided that a Piggieback-enabled ClojureScript environment is active in your
REPL session, code loading and evaluation will work seamlessly regardless of the
presence of the @pkg{cider-nrepl} middleware.  If the middleware is present,
most other features of CIDER will also be enabled (including code completion,
documentation lookup, the namespace browser, and macro-expansion).

@node Keyboard Shortcuts
@chapter Keyboard shortcuts

@itemize
@item
@kbd{M-x cider-jack-in}: Launch an nREPL server and a REPL client.  Prompts
for a project root if given a prefix argument.
@item
@kbd{M-x cider}: Connect to an already-running nREPL server.
@end itemize

While you're in @command{clojure-mode}, @command{cider-jack-in} is bound for convenience to
@kbd{C-c M-j} and @command{cider-connect} is bound to @kbd{C-c M-c}.

@section @command{cider-mode}

@ftable @command
@item @kbd{C-x C-e}
@itemx @kbd{C-c C-e}
Evaluate the form preceding point and display the result in the echo area.  If
invoked with a prefix argument, insert the result into the current buffer.

@item @kbd{C-c C-w}
Evaluate the form preceding point and replace it with its result.

@item @kbd{C-c M-e}
Evaluate the form preceding point and output it result to the REPL buffer.  If
invoked with a prefix argument, takes you to the REPL buffer after being
invoked.

@item @kbd{C-c M-p}
Load the form preceding point in the REPL buffer.

@item @kbd{C-c C-p}
Evaluate the form preceding point and pretty-print the result in a popup buffer.

@item @kbd{C-c C-f}
Evaluate the top level form under point and pretty-print the result in a popup
buffer.

@item @kbd{C-M-x}
@itemx @kbd{C-c C-c}
Evaluate the top level form under point and display the result in the echo area.

@item @kbd{C-u C-M-x}
@itemx @kbd{C-u C-c C-c}
Debug the top level form under point and walk through its evaluation

@item @kbd{C-c C-r}
Evaluate the region and display the result in the echo area.

@item @kbd{C-c C-b}
Interrupt any pending evaluations.

@item @kbd{C-c C-m}
Invoke @command{macroexpand-1} on the form at point and display the result in a
macroexpansion buffer.  If invoked with a prefix argument, @command{macroexpand}
is used instead of @command{macroexpand-1}.

@item @kbd{C-c M-m}
Invoke @clojf{clojure.walk/macroexpand-all} on the form at point and display the
result in a macroexpansion buffer.

@item @kbd{C-c C-n}
Eval the ns form.

@item @kbd{C-c M-n}
Switch the namespace of the REPL buffer to the namespace of the current buffer.

@item @kbd{C-c C-z}
Switch to the relevant REPL buffer.  Use a prefix argument to change the
namespace of the REPL buffer to match the currently visited source file.

@item @kbd{C-u C-u C-c C-z}
Switch to the REPL buffer based on a user prompt for a directory.

@item @kbd{C-c M-d}
 Display default REPL connection details, including project directory name,
 buffer namespace, host and port.

@item @kbd{C-c M-r}
Rotate and display the default nREPL connection.

@item @kbd{C-c M-o}
Clear the entire REPL buffer, leaving only a prompt.  Useful if you're running
the REPL buffer in a side by side buffer.

@item @kbd{C-c C-k}
Load (eval) the current buffer.

@item @kbd{C-c C-l}
Load (eval) a Clojure file.

@item @kbd{C-c C-x}
Reload all modified files on the classpath.  If invoked with a prefix argument,
reload all files on the classpath.  If invoked with a double prefix argument,
clear the state of the namespace tracker before reloading.

@item @kbd{C-c C-d d}
Display doc string for the symbol at point.  If invoked with a prefix argument,
or no symbol is found at point, prompt for a symbol.

@item @kbd{C-c C-d j}
Display JavaDoc (in your default browser) for the symbol at point.  If invoked
with a prefix argument, or no symbol is found at point, prompt for a symbol.

@item @kbd{C-c M-i}
Inspect expression.  Will act on expression at point if present.

@item @kbd{C-c M-t v}
Toggle var tracing.

@item @kbd{C-c M-t n}
Toggle namespace tracing.

@item @kbd{C-c C-u}
Undefine a symbol.  If invoked with a prefix argument, or no symbol is found at
point, prompt for a symbol.

@item @kbd{C-c ,}
Run tests for namespace.

@item @kbd{C-c C-,}
Re-run test failures/errors for namespace.

@item @kbd{C-c M-,}
Run test at point.

@item @kbd{C-c C-t}
Show the test report buffer.

@item @kbd{M-.}
Jump to the definition of a symbol.  If invoked with a prefix argument, or no
symbol is found at point, prompt for a symbol.

@item @kbd{C-c M-.}
Jump to the resource referenced by the string at point.

@item @kbd{C-c C-.}
Jump to some namespace on the classpath.

@item @kbd{M-,}
Return to your pre-jump location.

@item @kbd{M-TAB}
Complete the symbol at point.

@item @kbd{C-c C-d r}
Lookup symbol in Grimoire.

@item @kbd{C-c C-d a}
Apropos search for functions/vars.

@item @kbd{C-c C-d A}
Apropos search for documentation.
@end ftable



@section @command{cider-repl-mode}

@ftable @command
@item @kbd{RET}
Evaluate the current input in Clojure if it is complete.  If incomplete, open a
new line and indent.  If invoked with a prefix argument is given then the input
is evaluated without checking for completeness.

@item @kbd{C-RET}
Close any unmatched parenthesis and then evaluate the current input in Clojure.

@item @kbd{C-j}
Open a new line and indent.

@item @kbd{C-c M-o}
Clear the entire REPL buffer, leaving only a prompt.

@item @kbd{C-c C-o}
Remove the output of the previous evaluation from the REPL buffer.

@item @kbd{C-c C-u}
Kill all text from the prompt to the current point.

@item @kbd{C-c C-b}
@itemx @kbd{C-c C-c}
Interrupt any pending evaluations.

@item @kbd{C-up}
@itemx @kbd{C-down}
Goto to previous/next input in history.

@item @kbd{M-p}
@itemx @kbd{M-n}
Search the previous/next item in history using the current input as search
pattern.  If @kbd{M-p/M-n}is typed two times in a row, the second invocation
uses the same search pattern (even if the current input has changed).

@item @kbd{M-s}
@itemx @kbd{M-r}
Search forward/reverse through command history with regex.

@item @kbd{C-c C-n}
@itemx @kbd{C-c C-p}
Move between the current and previous prompts in the REPL buffer.  Pressing
@kbd{RET}on a line with old input copies that line to the newest prompt.

@item @kbd{C-c C-x}
Reload all modified files on the classpath.

@item @kbd{C-u C-c C-x}
Reload all files on the classpath.

@item @kbd{TAB}
Complete symbol at point.

@item @kbd{C-c C-d d}
Display doc string for the symbol at point.  If invoked with a prefix argument,
or no symbol is found at point, prompt for a symbol

@item @kbd{C-c C-d j}
Display JavaDoc (in your default browser) for the symbol at point.  If invoked
with a prefix argument, or no symbol is found at point, prompt for a symbol.

@item @kbd{C-c C-d r}
Lookup symbol in Grimoire.

@item @kbd{C-c C-d a}
Apropos search for functions/vars.

@item @kbd{C-c C-d A}
Apropos search for documentation.

@item @kbd{C-c C-z}
Switch to the previous Clojure buffer.  This complements @kbd{C-c C-z}used in
cider-mode.

@item @kbd{C-c M-i}
Inspect expression.  Will act on expression at point if present.

@item @kbd{C-c M-n}
Select a namespace and switch to it.

@item @kbd{C-c C-.}
Jump to some namespace on the classpath.

@item @kbd{C-c M-t v}
Toggle var tracing.

@item @kbd{C-c M-t n}
Toggle namespace tracing.

@end ftable

In the REPL you can also use ``shortcut commands'' by pressing @key{,} at the
beginning of a REPL line.  You'll be presented with a list of commands you can
quickly run (like quitting, displaying some info, clearing the REPL, etc).  The
character used to trigger the shortcuts is configurable via
@command{cider-repl-shortcut-dispatch-char}.  Here's how you can change it to
@key{:}:

@lisp
(setq cider-repl-shortcut-dispatch-char ?\:)
@end lisp

@section @command{cider-macroexpansion-mode}

@ftable @command
@item @kbd{C-c C-m}
Invoke @command{macroexpand-1} on the form at point and replace the original
form with its expansion.  If invoked with a prefix argument,
@command{macroexpand} is used instead of @command{macroexpand-1}.

@item @kbd{C-c M-m}
Invoke @clojf{clojure.walk/macroexpand-all} on the form at point and replace the
original form with its expansion.

@item @kbd{g}
The prior macroexpansion is performed again and the current contents of the
macroexpansion buffer are replaced with the new expansion.

@item @kbd{C-/}
@itemx @kbd{C-x u}
Undo the last inplace expansion performed in the macroexpansion buffer.
@end ftable

@section @command{cider-inspector-mode}

@ftable @command
@item @kbd{Tab}
@itemx @kbd{Shift-Tab}
navigate inspectable sub-objects

@item @kbd{Return}
inspect sub-objects

@item @kbd{l}
pop to the parent object

@item @kbd{g}
refresh the inspector (e.g. if viewing an atom/ref/agent)

@item @kbd{SPC}
jump to next page in paginated view

@item @kbd{M-SPC}
jump to previous page in paginated view

@item @kbd{s}
set a new page size in paginated view
@end ftable

@section @command{cider-test-report-mode}

@ftable @command
@item @kbd{C-c ,}
Run tests for namespace.

@item @kbd{C-c C-,}
Re-run test failures/errors for namespace.

@item @kbd{C-c M-,}
Run test at point.

@item @kbd{M-p}
Move point to previous test.

@item @kbd{M-n}
Move point to next test.

@item @kbd{t}
@itemx @kbd{M-.}
Jump to test definition.

@item @kbd{d}
Display diff of actual vs expected.

@item @kbd{e}
Display test error cause and stacktrace info.
@end ftable

@section @command{cider-stacktrace-mode}

@ftable @command
@item @kbd{M-p}
move point to previous cause

@item @kbd{M-n}
move point to next cause

@item @kbd{M-.}
@itemx @kbd{Return}
navigate to the source location (if available) for the stacktrace frame

@item @kbd{Tab}
Cycle current cause detail

@item @kbd{0}
@itemx @kbd{S-Tab}
Cycle all cause detail

@item @kbd{1}
Cycle cause #1 detail

@item @kbd{2}
Cycle cause #2 detail

@item @kbd{3}
Cycle cause #3 detail

@item @kbd{4}
Cycle cause #4 detail

@item @kbd{5}
Cycle cause #5 detail

@item @kbd{j}
toggle display of java frames

@item @kbd{c}
toggle display of clj frames

@item @kbd{r}
toggle display of repl frames

@item @kbd{t}
toggle display of tooling frames (e.g. compiler, nREPL middleware)

@item @kbd{d}
toggle display of duplicate frames

@item @kbd{a}
toggle display of all frames

@end ftable

@section @command{cider-debug}

The debugger can be invoked in several ways, the simplest one is to type
@kbd{C-u C-M-x}.  This will take the current top-level form, place as many
breakpoints inside it as possible (instrument it), and then evaluate it a
normal.  Whenever a breakpoint is reached, you'll be shown the value and asked
for input (see below).  Note that if the current form is a @code{defn}, it will
stay instrumented, so the debugger will be triggered every time the function is
called.  To uninstrument @code{defn} (or similar forms), you just have to
evaluate it again as you'd normally do (e.g. with @kbd{C-M-x}).

Another way to trigger the debugger is by placing breakpoints yourself.  Just
write @code{#break} before a form, and the debugger will popup every time that
form is evaluated.  For instance, if you hit @kbd{C-M-x} on the following, a
breakpoint is triggered every time @code{(inspector msg)} is evaluated.
@lisp
(defn eval-msg [@{:keys [inspect] :as msg@}]
  (if inspect
    #break (inspector msg)
    msg))
@end lisp

Instead of @code{#break} you can also write @code{#dbg} before a form, this will
not only breakpoint the form but also everything inside it.  In the example
above, this places a breakpoint around @code{(inspector msg)} and another around
@code{msg}.  If you've been paying attention, you may have noticed that the
first option (@kbd{C-u C-M-x}) is a quick way of evaluating the current
top-level form with @code{#dbg} in front.

At any point, you can bring up a list of all currently instrumented @code{def}s
with the command @command{cider-browse-instrumented-defs}.  Protocols and types
can be instrumented as well, but they will not be listed by this command.

@heading Keys

@command{cider-debug} tries to be consistent with
@uref{http://www.gnu.org/software/emacs/manual/html_node/elisp/Edebug.html,
Edebug}.  So it makes available the following bindings while stepping through
code.

@ftable @command
@item @kbd{n}
Next step

@item @kbd{c}
Continue without stopping

@item @kbd{o}
Move out of the current sexp (like @command{up-list})

@item @kbd{i}
Inject a value into running code

@item @kbd{e}
Eval code in current context

@item @kbd{l}
Inspect local variables

@item @kbd{q}
Quit execution
@end ftable

In addition, all the usual evaluation commands (such as @kbd{C-x C-e} or
@kbd{C-c M-:}) will use the current lexical context (local variables) while the
debugger is active.

@section Managing multiple sessions

You can connect to multiple nREPL servers using @kbd{M-x cider-jack-in} multiple
times.  To close the current nREPL connection, use @kbd{M-x cider-quit}.

CIDER maintains a list of nREPL connections and a single `default' connection.
When you execute CIDER commands in a Clojure editing buffer such as to compile a
namespace, these commands are executed against the default connection.

You can display the default nREPL connection using @kbd{C-c M-d} and rotate
the default connection using @kbd{C-c M-r}.  Another option for setting the
default connection is to execute the command @kbd{M-x
nrepl-make-connection-default} in the appropriate REPL buffer.

To switch to the relevant REPL buffer based on the Clojure namespace in the
current Clojure buffer, use @kbd{C-c C-z}.  You can then use the same key
combination to switch back to the Clojure buffer you came from.

The single prefix @kbd{C-u C-c C-z}, will switch you to the relevant REPL buffer
and set the namespace in that buffer based on namespace in the current Clojure
buffer.

To explicitly choose the REPL buffer that @kbd{C-c C-z} uses based on project
directory, use a double prefix @kbd{C-u C-u C-c C-z}.  This assumes you have
@command{cider-switch-to-relevant-repl} mapped to the var
@command{cider-switch-to-repl-command} which is the default configuration.

To change the designation used for CIDER buffers use @kbd{M-x
cider-change-buffers-designation}.  This changes the CIDER REPL buffer, nREPL
connection buffer and nREPL server buffer.  For example using
@command{cider-change-buffers-designation} with the string @code{"foo"} would
change @buffer{*cider-repl localhost*} to @buffer{*cider-repl foo*}.

@node Requirements
@chapter Requirements

@itemize
@item
@uref{http://leiningen.org, Leiningen} 2.x (only for @command{cider-jack-in})

@item
@uref{http://www.gnu.org/software/emacs/emacs.html, GNU Emacs} 24.3+.

@item
@uref{http://clojure.org, Clojure} 1.5.0+
@end itemize

@node Caveats
@chapter Caveats
@section Var Metadata

Currently variable metadata about the location of the variable's definition
within the source code (file, line, and column) is set only when evaluating the
entire source buffer (@kbd{C-c C-k}).  All other interactive code evaluation
commands (e.g. @kbd{C-c C-e}) don't set this metadata and you won't be able to
use commands like @command{find-var} on such vars.  That's a
@uref{http://dev.clojure.org/jira/browse/NREPL-59, limitation of nREPL}, that's
beyond CIDER.  If you want to see interactive evaluation working properly in
CIDER you'll have to push for the aforementioned nREPL issue to be resolved.

@section ClojureScript limitations

Currently, the following features are not supported for ClojureScript
development:
@itemize
@item
Grimoire lookup
@item
Reloading
@item
Running tests
@item
Tracing
@end itemize
There is currently no support for both Clojure and ClojureScript evaluation in
the same nREPL session.  If Piggieback is active, code evaluation and all
features will assume ClojureScript.

The aforementioned @uref{http://github.com/symfrog/clojure-quick-repls,
clojure-quick-repls} aids this situation by routing requests to the correct REPL
according to the file extension of the current buffer.

@section Microsoft Windows
On Microsoft Windows the JVM default line separator string is @code{"@backslashcahr{}r@backslashcahr{}n"}
which can appear in Emacs as @code{^M} characters at the end of lines printed
out by the JVM.  One option is to set the @var{buffer-display-table} to not show
these characters as detailed @uref{http://stackoverflow.com/a/11787550, here}
(changing @var{slime-repl-mode-hook} to @var{cider-repl-mode-hook}).
Alternatively, setting the system property @code{line.separator} to @code{"@backslashcahr{}n"}
at JVM startup will stop the carriage return from being printed and will fix
output in all cider buffers.  To do so add @code{"-Dline.separator=\"\n\""} to
@code{:jvm-opts} in @file{~/.lein/profiles.clj}.

@section @pkg{powershell.el}
The powershell inferior shell mode truncates CIDER's REPL output when loaded.
As a workaround, remove
@lisp
(require 'powershell)
@end lisp
from your Emacs config.

@node Troubleshooting
@chapter Troubleshooting
In case you run into issues here are a few tips that can help you diagnose the
problem.

Generally, it's not a bad idea to configure Emacs to spit the backtrace on error
(instead of just logging the error in the @buffer{*Messages*} buffer.  You can toggle
this behavior by using @kbd{M-x toggle-debug-on-error}.

@section REPL not starting

Make sure that your CIDER version matches your @file{cider-nrepl} version.
Check the contents of the @buffer{*Messages*} buffer for CIDER-related errors.  You
should also check the nREPL messages passed between CIDER and nREPL in
@buffer{*nrepl-messages*}.  If you don't see anything useful there it's time to bring
out the big guns.

@heading Debugging the REPL init

Emacs features a super powerful built-in
@uref{http://www.gnu.org/software/emacs/manual/html_node/elisp/Edebug.html,
Emacs Lisp debugger} and using it is the best way to diagnose problems of any
kind.  To debug CIDER's REPL initialization it's a good idea to hook into one of
its entry points.  Add a breakpoint to @command{cider-make-repl} (@kbd{C-u
C-M-x}, while its body).  Next time you start CIDER you'll be dropped in the
debugger and you can step forward until you find the problem.

Here's a @uref{http://www.youtube.com/watch?v=odkYXXYOxpo, great crash course} on
using the debugger.

@section Missing @buffer{*nrepl-messages*} buffer

Check the value of @var{nrepl-log-messages}.  It should be non-nil.

@section @command{cider-debug} complains that it ``failed to instrument ...''

In the REPL buffer, issue the following.
@verbatim
your.namespace> (ns cider.nrepl.middleware.util.instrument)
cider.nrepl.middleware.util.instrument> (def verbose-debug true)
@end verbatim
This will cause CIDER to print extensive information on the REPL buffer when you
try to debug an expression (e.g., with @kbd{C-u C-M-x}).
@uref{http://github.com/clojure-emacs/cider/issues/new, File an issue} and
copy this information.

@section Warning saying you have to use nREPL 0.2.7+

CIDER currently requires at least nREPL 0.2.7 to work properly (there were some
nasty bugs in 0.2.6).  Unfortunately, the latest Leiningen (2.5.1) pulls in
exactly 0.2.6, so you if you're a lein user you'll have to do a bit of manual
work.  Just add this to your @file{profiles.clj}:
@lisp
@{:user @{:dependencies [[org.clojure/tools.nrepl "0.2.10"]]@}@}
@end lisp
Make sure you add the newer nREPL dependency to the @code{:dependencies} key
instead of @code{:plugins} (where @pkg{cider-nrepl} Lein plugin resides).
That's a pretty common mistake.

Generally you're advised to use the newest nREPL with CIDER, as bugs get fixed
in pretty much every release.

Note, that running @command{cider-jack-in} from outside the scope of a project
will result in the @strong{older (0.2.6) nREPL dependency being used} (at least
on Leiningen 2.5.1).  This is likely a Leiningen bug.

@node Documentation
@chapter Documentation

A single-page quick reference PDF for CIDER commands is available
@uref{doc/cider-refcard.pdf, here}.  This PDF can be created manually by
running @code{pdflatex} on the CIDER refcard LaTeX file,
@uref{http://github.com/clojure-emacs/cider/blob/master/doc/cider-refcard.tex,
@file{doc/cider-refcard.tex}}.

@node Changelog
@chapter Changelog

An extensive changelog is available in
@uref{http://github.com/clojure-emacs/cider/blob/master/CHANGELOG.md,
@file{CHANGELOG.md}}.

@node Team
@chapter Team

@itemize
@item
@uref{http://github.com/bbatsov, Bozhidar Batsov} (maintainer)

@item
@uref{http://github.com/kingtim, Tim King} (original author)

@item
@uref{http://github.com/technomancy, Phil Hagelberg}

@item
@uref{http://github.com/hugoduncan, Hugo Duncan}

@item
@uref{http://github.com/purcell, Steve Purcell}

@item
@uref{http://github.com/jeffvalk, Jeff Valk}
@end itemize


@node Release Policy
@chapter Release Policy

We're following @uref{http://semver.org, SemVer} (as much as one can be
following it when the major version is @samp{0}).  At this point bumps
to the minor version number are considered major releases and always
include new features or significant changes to existing features.  API
compatibility between major releases is not a (big) concern, although we
try to break the API rarely and only for a good reason.

The development cycle for the next major release starts immediately
after the previous one has been shipped.  Bugfix/point releases (if any)
address only serious bugs and never contain new features.

The versions of CIDER and @file{cider-nrepl} are always kept in sync.
If you're tracking the @branch{master} branch of CIDER, you should also be
tracking the @branch{master} branch of @file{cider-nrepl}.

@node Logo
@chapter Logo

CIDER's logo was created by @uref{http://github.com/ndr-qef, @@ndr-qef}.
You can find the logo in various formats in
@uref{http://github.com/clojure-emacs/cider/tree/master/logo, the
@file{logo/} directory}.

The logo is licensed under a
@uref{http://creativecommons.org/licenses/by-nc/4.0/deed.en_GB, Creative
Commons Attribution-NonCommercial 4.0 International License}.

@node Contributing
@chapter Contributing


@section Discussion

For questions, suggestions and support refer to our
@uref{http://groups.google.com/forum/#!forum/cider-emacs, official
mailing list}, the Freenode channel @t{#clojure-emacs}, @t{#cider} on
@uref{http://clojurians.slack.com, slack} or our
@uref{http://gitter.im/clojure-emacs/cider, Gitter channel}.
@emph{Please}, do not report issues there!  This makes them harder to
track and resolve.

@section Issues

Report issues and suggest features and improvements on the
@uref{http://github.com/clojure-emacs/cider/issues, GitHub issue tracker}.
Don't ask questions on the issue tracker -- the mailing list and the IRC channel
are the places for questions.

If you want to file a bug, please clone this repo and provide sufficient details
to reproduce the issue.  Start by running @code{make run-cider}.  This will
bring up Emacs with only the latest version of CIDER loaded.  By starting fresh,
with the latest code, we can ensure that the problem at hand isn't already fixed
or caused by interactions with other packages.

@section Patches

Patches under any form are always welcome! GitHub pull requests are even
better! @t{:-)}

Before submitting a patch or a pull request make sure all tests are
passing and that your patch is in line with the
@uref{http://github.com/clojure-emacs/cider/blob/master/CONTRIBUTING.md,
contribution guidelines}.

@section Documentation

Consider improving and extending the
@uref{http://github.com/clojure-emacs/cider/wiki, community wiki}.

@section Running the tests in batch mode

Install @uref{http://github.com/rejeep/cask.el, Cask} if you haven't
already, then:
@verbatim
$ cd /path/to/cider
$ cask
@end verbatim

Run all tests with:
@verbatim
$ make test
@end verbatim

(Note: tests may not run correctly inside Emacs' @command{shell-mode}
buffers.  Running in a terminal is recommended.)

@node License
@chapter License

Copyright @copyright{} 2012--2015
Tim King,
Phil Hagelberg,
Bozhidar Batsov,
Hugo Duncan,
Steve Purcell and
@uref{http://github.com/clojure-emacs/cider/contributors, contributors}.

Distributed under the GNU General Public License, version 3.

@node Copying This Manual
@appendix Copying This Manual

@menu
* GNU Free Documentation License:: License for copying this manual.
@end menu

@node GNU Free Documentation License
@section GNU Free Documentation License
@include fdl.texi

@bye

@c cider.texi ends here
